partialtargetx <- numeric()
partialtargety <- numeric()
partialrx <- numeric()
partialry <- numeric()
partialinside <- logical()
lastCalculatedPointY <- 0
#for (n in indexes ) {
for (n in 1:nrow(partial) ) {
#dataRaw$targetx[n]<-target[1,1]
#dataRaw$targety[n]<-target[1,2]
#partial$targetx[n]<-target[1,1]
#partial$targety[n]<-target[1,2]
partialtargetx[n]<-target[1,1]
partialtargety[n]<-target[1,2]
#point <- c(dataRaw[n,]$MouseX, dataRaw[n,]$MouseY)-axisStart
point <- c(partial[n,]$MouseX, partial[n,]$MouseY)-axisStart
# transform the coordinate
newPoint <- rotate(point, angle )
#dataRaw$rx[n]<-newPoint[1,1]
#dataRaw$ry[n]<-newPoint[1,2]
#partial$rx[n]<-newPoint[1,1]
#partial$ry[n]<-newPoint[1,2]
partialrx[n]<-newPoint[1,1]
partialry[n]<-newPoint[1,2]
#Check for noise
if (abs(partialry[n]) > 400) {
print(paste("Correcting coordinate due to noise", partialry[n]))
partialry[n] <- lastCalculatedPointY
}
lastCalculatedPointY <- partialry[n]
clickPointX <- newPoint[1,1]
clickPointY <- newPoint[1,2]
#TRE
if (dist(rbind(newPoint, target)) < partial[n,]$TargetWidth/2) {
if ( !entered ) {
entered <- TRUE
TRE <- TRE + 1
}
#partial$inside[n]<-TRUE
partialinside[n]<-TRUE
}else {
entered <- FALSE
#partial$inside[n]<-FALSE
partialinside[n]<-FALSE
}
#TAC
curY <- newPoint[1, 2]
if ( prevTACY*curY < 0 ) {
TAC <- TAC +1
}
prevTACY <- curY
#MDC
curDif <- curY-prevMDCY
if ( prevMDCDif * curDif < 0 ) {
MDC <- MDC +1
#print("+1")
}
if ( curDif != 0 ) {
prevMDCDif <- curDif
}
prevMDCY <- curY
#ODC
curX <- newPoint[1, 1]
curDif <- curX-prevODCX
if ( prevODCDif * curDif < 0 ) {
ODC <- ODC +1
}
if ( curDif != 0 ) {
prevODCDif <- curDif
}
prevODCX <- curX
#MO
MO <- MO + curY
#MV
ys <- append(ys, curY)
}
#MO
MO <- MO / length(indexes)
#MV
MV <- sqrt(sum((ys-MO)*(ys-MO))/(length(indexes)-1))
#ME
ME <- sum(abs(ys))/length(indexes)
row <- c(partial[1,]$NumberDevice, partial[1,]$UserId, partial[1,]$Block, partial[1,]$Sequence, partial[1,]$CircleID, errorRate, TRE, TAC, MDC, ODC, MV, ME, MO, clickPointX, clickPointY, partial[1,]$ElapsedTime/1000, partial[1,]$TargetWidth, partial[1,]$DistanceCenter*2, calculatedDistance)
dataMeasures <- rbind(dataMeasures, row)
partial$targetx <- partialtargetx
partial$targety <- partialtargety
partial$rx <- partialrx
partial$ry <- partialry
partial$inside <- partialinside
#newData <- rbind(newData, partial)
newDataSequence <- rbind(newDataSequence, partial)
}
newDataBlock <- rbind(newDataBlock, newDataSequence)
}
newDataDevice <- rbind(newDataDevice, newDataBlock)
}
newData <- rbind(newData, newDataDevice)
}
)
# Functions
rotationMatrix <- function(angle) {
matrix <- matrix(c(cos(angle), sin(angle), -sin(angle), cos(angle)), nrow = 2, ncol = 2)
return(matrix)
}
rotate <- function(point, angle) {
return( point %*% rotationMatrix(angle) )
}
angleBetween <- function(v1, v2) {
dot <- sum(v1*v2);# v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
v1mag <- sqrt(v1[1] * v1[1] + v1[2] * v1[2] );
v2mag <- sqrt(v2[1] * v2[1] + v2[2] * v2[2] );
amt <- dot / (v1mag * v2mag);
if (amt <= -1) {
return (pi)
} else if (amt >= 1) {
return (0)
}
return ( acos(amt) );
}
rotateAround <- function(referencePoint, point, angle) {
displacement <- point-referencePoint
rotatedPoint <- rotate(point-displacement, angle)
rotatedPoint <- rotatedPoint + displacement
return( rotatedPoint)
}
toDegrees <- function(radians) {
return( radians*360/(2*pi) )
}
############################ data
device <- "all"
filename <- paste("data/",device,".txt", sep="")
filenameTransformed <- paste("data/", device,"-transformed.txt", sep="")
filenameMeasures <- paste("data/", device,"-measures.txt", sep="")
dataRaw <- read.csv(file=filename, head=TRUE, sep="")
dataMeasures <- data.frame()
newData <- data.frame()
#For noise errors checking
countNoiseErrors <- 0
system.time(
for (device in unique(dataRaw$NumberDevice) ) {
print(paste("Device: ", device))
newDataDevice <- data.frame()
for (block in 1:max(dataRaw$Block) ) {
#for (block in 1:1 ) {
print(paste("Block: ", block))
newDataBlock <- data.frame()
for (sequence in 1:max(dataRaw$Sequence) ) {
#for (sequence in 1:1 ) {
print(paste("Sequence: ", sequence))
newDataSequence <- data.frame()
for (cid in 1:max(dataRaw$CircleID) ) {
#for (cid in 1 ) {
#indexes for the current target selection
indexes <- which(dataRaw$NumberDevice == device & dataRaw$Block == block & dataRaw$Sequence == sequence & dataRaw$CircleID == cid)
partial <- dataRaw[indexes, ]
#print(paste("CircleID: ", cid, " samples: ", length(indexes)))
# we consider the movement axis as a line goind from the first point to the center of the target
axisStart <- c(partial[1,]$MouseX, partial[1,]$MouseY)
axisEnd <- c(partial[nrow(partial),]$PixelEndCircleX, partial[nrow(partial),]$PixelEndCircleY)
axis <- axisEnd-axisStart
#print(axis)
# TODO: check why some selections started and ended on the same point
# these lines guarantee that we skip these errors
if (axis[1] == 0 & axis[2] == 0 ) {
print(paste("Error? Block:", block, " Sequence: ", sequence, " CircleID: ", cid, " Axis:", axis))
next
}
# we will transform the coordinates so that the movements axis is horizontal, and starts at (0, 0)
angle <- angleBetween( c(1, 0), axis )
if ( axis[2] < 0) {
angle <- -angle
}
# transform also the target coordinates, so we can calculate the TRE measure
point <- c(dataRaw[indexes[1],]$PixelEndCircleX, dataRaw[indexes[1],]$PixelEndCircleY)-axisStart
target <- rotate(point, angle )
#dataRaw$targetx[indexes[1]]<-target[1,1]
#dataRaw$targety[indexes[1]]<-target[1,2]
# calculated distance (first click - target)
calculatedDistance <- dist(rbind(target, c(0,0)))[1]
# go through all coordinates, transform them and calculate the various measures.
errorRate <- (partial[1,]$NumberClicks-1)/partial[1,]$NumberClicks
TRE <- -1
entered <- FALSE
TAC <- 0
prevTACY <- 0
MDC <- 0
prevMDCY <- 0
prevMDCDif <- 0
ODC <- 0
prevODCX <- 0
prevODCDif <- 0
MO <- 0
MV <- 0
ys <- c()
ME <- 0
# will hold the click point (transformed) this is the last coordinate found in the selection movement
clickPointX <- 0
clickPointY <- 0
partialtargetx <- numeric()
partialtargety <- numeric()
partialrx <- numeric()
partialry <- numeric()
partialinside <- logical()
# for noise errors checking
lastCalculatedPointY <- 0
#for (n in indexes ) {
for (n in 1:nrow(partial) ) {
#dataRaw$targetx[n]<-target[1,1]
#dataRaw$targety[n]<-target[1,2]
#partial$targetx[n]<-target[1,1]
#partial$targety[n]<-target[1,2]
partialtargetx[n]<-target[1,1]
partialtargety[n]<-target[1,2]
#point <- c(dataRaw[n,]$MouseX, dataRaw[n,]$MouseY)-axisStart
point <- c(partial[n,]$MouseX, partial[n,]$MouseY)-axisStart
# transform the coordinate
newPoint <- rotate(point, angle )
#dataRaw$rx[n]<-newPoint[1,1]
#dataRaw$ry[n]<-newPoint[1,2]
#partial$rx[n]<-newPoint[1,1]
#partial$ry[n]<-newPoint[1,2]
partialrx[n]<-newPoint[1,1]
partialry[n]<-newPoint[1,2]
#Check for noise
if (abs(partialry[n]) > 400) {
print(paste("Correcting coordinate due to noise", partialry[n]))
partialry[n] <- lastCalculatedPointY
countNoiseErrors <- countNoiseErrors +1
}
lastCalculatedPointY <- partialry[n]
clickPointX <- newPoint[1,1]
clickPointY <- newPoint[1,2]
#TRE
if (dist(rbind(newPoint, target)) < partial[n,]$TargetWidth/2) {
if ( !entered ) {
entered <- TRUE
TRE <- TRE + 1
}
#partial$inside[n]<-TRUE
partialinside[n]<-TRUE
}else {
entered <- FALSE
#partial$inside[n]<-FALSE
partialinside[n]<-FALSE
}
#TAC
curY <- newPoint[1, 2]
if ( prevTACY*curY < 0 ) {
TAC <- TAC +1
}
prevTACY <- curY
#MDC
curDif <- curY-prevMDCY
if ( prevMDCDif * curDif < 0 ) {
MDC <- MDC +1
#print("+1")
}
if ( curDif != 0 ) {
prevMDCDif <- curDif
}
prevMDCY <- curY
#ODC
curX <- newPoint[1, 1]
curDif <- curX-prevODCX
if ( prevODCDif * curDif < 0 ) {
ODC <- ODC +1
}
if ( curDif != 0 ) {
prevODCDif <- curDif
}
prevODCX <- curX
#MO
MO <- MO + curY
#MV
ys <- append(ys, curY)
}
#MO
MO <- MO / length(indexes)
#MV
MV <- sqrt(sum((ys-MO)*(ys-MO))/(length(indexes)-1))
#ME
ME <- sum(abs(ys))/length(indexes)
row <- c(partial[1,]$NumberDevice, partial[1,]$UserId, partial[1,]$Block, partial[1,]$Sequence, partial[1,]$CircleID, errorRate, TRE, TAC, MDC, ODC, MV, ME, MO, clickPointX, clickPointY, partial[1,]$ElapsedTime/1000, partial[1,]$TargetWidth, partial[1,]$DistanceCenter*2, calculatedDistance)
dataMeasures <- rbind(dataMeasures, row)
partial$targetx <- partialtargetx
partial$targety <- partialtargety
partial$rx <- partialrx
partial$ry <- partialry
partial$inside <- partialinside
#newData <- rbind(newData, partial)
newDataSequence <- rbind(newDataSequence, partial)
}
newDataBlock <- rbind(newDataBlock, newDataSequence)
}
newDataDevice <- rbind(newDataDevice, newDataBlock)
}
newData <- rbind(newData, newDataDevice)
}
)
names(dataMeasures) <- c("DeviceNumber", "UserId", "Block", "Sequence", "CircleID", "ErrorRate", "TRE", "TAC", "MDC", "ODC", "MV", "ME", "MO", "ClickPointX", "ClickPointY", "MovementTime", "TargetWidth", "Distance", "CalculatedDistance")
#
print(paste("Noise errors found: ", countNoiseErrors))
#Calculate throughput
meanX <- mean(dataMeasures$ClickPointX)
meanY <- mean(dataMeasures$ClickPointY)
diffX <- dataMeasures$ClickPointX-meanX
diffY <- dataMeasures$ClickPointY-meanY
diffSQX <- diffX*diffX
diffSQY <- diffY*diffY
SD <- sqrt(sum(diffSQX+diffSQY)/length(diffX))
We <- 4.133*SD
IDe <- log(dataMeasures[1,]$Distance/We + 1)
Throughput <- IDe/dataMeasures$MovementTime
write.table(newData, file = filenameTransformed, sep=" ", row.names=FALSE)
write.table(dataMeasures, file = filenameMeasures, sep=" ", row.names=FALSE)
# Plot the calculated distances
plot(dataMeasures[dataMeasures$DeviceNumber==0,]$CalculatedDistance)
toplot <- newData[newData$NumberDevice==2 & newData$Block == 1 & newData$Sequence == 1 & newData$CircleID ==3, ]
plot(toplot$rx,
toplot$ry, type='l')
#require(RCurl) # web
require(ggplot2)
require(doBy)
#library("stringr") # for first word
#library(reshape)
#theme_set(theme_bw())
# Multiple plot function
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
require(grid)
# Make a list from the ... arguments and plotlist
plots <- c(list(...), plotlist)
numPlots = length(plots)
# If layout is NULL, then use 'cols' to determine layout
if (is.null(layout)) {
# Make the panel
# ncol: Number of columns of plots
# nrow: Number of rows needed, calculated from # of cols
layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
ncol = cols, nrow = ceiling(numPlots/cols))
}
if (numPlots==1) {
print(plots[[1]])
} else {
# Set up the page
grid.newpage()
pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
# Make each plot, in the correct location
for (i in 1:numPlots) {
# Get the i,j matrix positions of the regions that contain this subplot
matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
layout.pos.col = matchidx$col))
}
}
}
############################ data
#dataTransformedLeap <- read.csv(file="data/leapmotion-transformed.txt", head=TRUE, sep="")
#dataTransformedTouch <- read.csv(file="data/touchpad-transformed.txt", head=TRUE, sep="")
#dataTransformedMouse <- read.csv(file="data/mouse-transformed.txt", head=TRUE, sep="")
#dataTransformed <- rbind(dataTransformedLeap, dataTransformedTouch, dataTransformedMouse)
dataTransformed <- read.csv(file="data/all-transformed.txt", head=TRUE, sep="")
# change column name to get a nicer chart
colnames(dataTransformed)[colnames(dataTransformed)=="NumberDevice"] <- "Device"
# convert the column to factor and name the levels
dataTransformed$Device <- as.factor(dataTransformed$Device)
levels(dataTransformed$Device) <- c("LeapMotion",  "Mouse", "Touchpad")
#calculate the maximum and minimum y and x coords for setting the plots' scales
minX <- min(dataTransformed$rx)
maxX <- max(dataTransformed$rx)
minY <- min(dataTransformed$ry)
maxY <- max(dataTransformed$ry)
print ( paste("X scale: ", minX, maxX, " Y scale: ", minY, maxY))
# plot the paths for each user and device. a single plot aggregates one entire sequence
for (device in levels(dataTransformed$Device) ) {
for (user in 24) {
p <- ggplot(dataTransformed[dataTransformed$Device==device &
dataTransformed$UserId==24,],
aes(x=rx, y=ry, group=Device, colour=Device )) +
geom_line() +
coord_cartesian(xlim = c(minX, maxX), ylim=c(minY, maxY)) +
facet_grid(Block ~ Sequence) +
ylab("Block") +
xlab("Sequence") +
theme(legend.position="none") +
ggtitle(paste("Device: ", device, " User: ", user))
p
filename <- paste("charts/paths/byblocksequence", device, "-user-", user, ".pdf", sep="")
print( filename  )
ggsave(file = filename, width=21/2.54, height=29/2.54, dpi=100)
}
}
# plot the paths for each user and device. a single plot aggregates one circleid
for (device in levels(dataTransformed$Device) ) {
for (user in 24) {
p <- ggplot(dataTransformed[dataTransformed$Device==device &
dataTransformed$UserId==24,],
aes(x=rx, y=ry, group=Device, colour=Device )) +
geom_line() +
coord_cartesian(xlim = c(minX, maxX), ylim=c(minY, maxY)) +
facet_grid(CircleID ~ .) +
ylab("Circle ID") +
xlab("x") +
theme(legend.position="none") +
ggtitle(paste("Device: ", device, " User: ", user))
p
filename <- paste("charts/paths/bycircleid-", device, "-user-", user, ".pdf", sep="")
print( filename )
ggsave(file = filename, width=21/2.54, height=29/2.54, dpi=100)
}
}
# plot INDIVIDUAL paths for each user and device.
# PRODUCES LOTS OF FILES
for (device in levels(dataTransformed$Device) ) {
for (user in 24) {
for (block in 1:10) {
p <- ggplot(dataTransformed[dataTransformed$Device==device &
dataTransformed$Block==block &
dataTransformed$UserId==24,],
aes(x=rx, y=ry, group=Device, colour=Device )) +
geom_line() +
coord_cartesian(xlim = c(minX, maxX), ylim=c(minY, maxY)) +
facet_grid(CircleID ~ Sequence) +
ylab("Circle Id") +
xlab("Block") +
theme(legend.position="none") +
ggtitle(paste("Device: ", device, " User: ", user, " Block: ", block))
p
filename <- paste("charts/paths/individual-", device, "-user-", user, "-block-", block,".pdf", sep="")
print( filename )
ggsave(file = filename, width=29/2.54, height=35/2.54, dpi=100)
}
}
}
# # plot the aggregated paths each device
# dataLastBlock <- dataTransformed[dataTransformed$Block==10, ]
# p1 <- ggplot(dataLastBlock[dataLastBlock$Device=="Mouse",], aes(x=rx, y=ry, group=Device, colour=Device )) +
#     geom_line() +
#     coord_cartesian(xlim = c(0, 1000), ylim=c(-250, 250))
#
# p2 <- ggplot(dataLastBlock[dataLastBlock$Device=="LeapMotion",], aes(x=rx, y=ry, group=Device, colour=Device )) +
#     geom_line() +
#     coord_cartesian(xlim = c(0, 1000), ylim=c(-250, 250))
#
# p3 <- ggplot(dataLastBlock[dataLastBlock$Device=="Touchpad",], aes(x=rx, y=ry, group=Device, colour=Device )) +
#     geom_line() +
#     coord_cartesian(xlim = c(0, 1000), ylim=c(-250, 250)) +
#     facet_grid(Sequence ~ .)
#
# multiplot(p1, p2, p3, cols=1)
#require(RCurl) # web
require(ggplot2)
require(doBy)
#library("stringr") # for first word
#library(reshape)
#theme_set(theme_bw())
############################ data
#dataMeasuresLeap <- read.csv(file="data/leapmotion-measures.txt", head=TRUE, sep="")
#dataMeasuresTouch <- read.csv(file="data/touchpad-measures.txt", head=TRUE, sep="")
#dataMeasuresMouse <- read.csv(file="data/mouse-measures.txt", head=TRUE, sep="")
#dataMeasures <- rbind(dataMeasuresLeap, dataMeasuresTouch, dataMeasuresMouse)
dataMeasures <- read.csv(file="data/all-measures.txt", head=TRUE, sep="")
# change column name to get a nicer chart
colnames(dataMeasures)[colnames(dataMeasures)=="DeviceNumber"] <- "Device"
# convert the column to factor and name the levels
dataMeasures$Device <- as.factor(dataMeasures$Device)
levels(dataMeasures$Device) <- c("LeapMotion",  "Mouse", "Touchpad")
# print summary stats
s <- summaryBy(ErrorRate+TRE+TAC+MDC+ODC+MV+ME+MO+MovementTime~Device,
data=dataMeasures,
FUN=c(mean,sd))
t(s)
# plot the movement time over block for each device
p <- ggplot(dataMeasures, aes(x=Block, y=MovementTime, group=Device, colour=Device ))
p + stat_summary(fun.y="mean", geom="line") + stat_summary(fun.y="mean", geom="point", aes(shape=Device))
ggsave(file = "charts/movementtime-block.pdf", width=20/2.54, height=16/2.54, dpi=100)
# plot the movement offset over the TRE for each device
p <- ggplot(s, aes(x=TRE.mean, y=abs(MO.mean), group=Device, colour=Device ))
p + geom_point(size=5, aes(shape=Device)) + coord_cartesian(xlim = c(0, 0.4), ylim=c(0, 8)) +
ylab("Movement offset (pixels)") +
xlab("Target Re-Entry")
ggsave(file = "charts/MO-TRE.pdf", width=20/2.54, height=16/2.54, dpi=100)
# analysis of variance
bartlett.test(MovementTime~Device,data=dataMeasures)
a <- aov(MovementTime~Device,data=dataMeasures)
summary(a)
a <- aov(ErrorRate~Device,data=dataMeasures)
summary(a)
a <- aov(TRE~Device,data=dataMeasures)
summary(a)
a <- aov(TAC~Device,data=dataMeasures)
summary(a)
a <- aov(MDC~Device,data=dataMeasures)
summary(a)
a <- aov(ODC~Device,data=dataMeasures)
summary(a)
a <- aov(MV~Device,data=dataMeasures)
summary(a)
a <- aov(ME~Device,data=dataMeasures)
summary(a)
a <- aov(MO~Device,data=dataMeasures)
summary(a)
names(dataMeasures)
boxplot(dataMeasures$MovementTime)
